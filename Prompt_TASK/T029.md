ЗАДАЧА T029: Клиент amoCRM и создание лидов

⚠️ ВАЖНО: НЕ ТРОГАЙ .env ФАЙЛ!

КОНТЕКСТ:
- Фазы 0-4 завершены ✅
- US1 (Avito), US2 (Telegram/Веб), US3 (RAG/Документы) работают
- Начинаем US4: Интеграция CRM, календаря и платежей
- Создана интеграция в amoCRM (subdomain: 2061alex)
- Client ID и Secret уже в .env файле

ЦЕЛЬ T029:
Реализовать OAuth 2.0 клиент amoCRM для автоматического создания лидов из диалогов

ТРЕБОВАНИЯ:
- OAuth 2.0 авторизация с автообновлением токенов
- Кеширование токенов в Redis (TTL 86400 сек, обновление за 1 час)
- API методы: create_lead, create_contact, add_note, get_lead
- Обработка rate limit с exponential backoff
- Маппинг данных из диалогов → amoCRM формат
- Сохранение истории диалога в примечаниях лида

СОЗДАТЬ ФАЙЛЫ:

1. app/integrations/amocrm/__init__.py (НОВЫЙ)
```python
"""Интеграция с amoCRM."""
from app.integrations.amocrm.client import AmoCRMClient

__all__ = ["AmoCRMClient"]
```

2. app/integrations/amocrm/models.py (НОВЫЙ)
```python
"""Pydantic модели для amoCRM API."""
from datetime import datetime
from typing import Literal
from pydantic import BaseModel, Field


class AmoCRMTokens(BaseModel):
    """OAuth токены amoCRM."""
    access_token: str
    refresh_token: str
    expires_in: int
    token_type: str = "Bearer"
    created_at: datetime = Field(default_factory=datetime.now)
    
    def is_expired(self) -> bool:
        """Проверяет истёк ли токен (с запасом 1 час)."""
        age = (datetime.now() - self.created_at).total_seconds()
        return age >= (self.expires_in - 3600)


class AmoCRMCustomField(BaseModel):
    """Кастомное поле amoCRM."""
    field_id: int
    values: list[dict]


class AmoCRMContact(BaseModel):
    """Контакт amoCRM."""
    name: str
    first_name: str | None = None
    last_name: str | None = None
    custom_fields_values: list[AmoCRMCustomField] | None = None


class AmoCRMLead(BaseModel):
    """Лид amoCRM."""
    name: str
    price: int | None = None
    pipeline_id: int | None = None
    status_id: int | None = None
    responsible_user_id: int | None = None
    custom_fields_values: list[AmoCRMCustomField] | None = None
    _embedded: dict | None = None


class AmoCRMNote(BaseModel):
    """Примечание к лиду."""
    entity_id: int
    entity_type: Literal["leads", "contacts", "companies"]
    note_type: Literal["common"] = "common"
    params: dict


class LeadCreateRequest(BaseModel):
    """Запрос на создание лида из диалога."""
    user_name: str
    phone: str | None = None
    email: str | None = None
    source: Literal["telegram", "avito", "web"] = "telegram"
    product_interest: str | None = None  # AI Manager/Lawyer/Analyst
    budget: int | None = None
    conversation_history: str | None = None
    metadata: dict | None = None


class LeadCreateResponse(BaseModel):
    """Ответ на создание лида."""
    lead_id: int
    contact_id: int | None = None
    success: bool
    message: str
```

3. app/integrations/amocrm/auth.py (НОВЫЙ)
```python
"""OAuth 2.0 авторизация для amoCRM."""
import asyncio
from datetime import datetime

import httpx
from loguru import logger

from app.core.cache import redis_client
from app.core.config import get_settings
from app.integrations.amocrm.models import AmoCRMTokens


class AmoCRMAuthManager:
    """Менеджер OAuth авторизации amoCRM."""
    
    REDIS_KEY = "amocrm:tokens"
    TOKEN_TTL = 86400  # 24 часа
    
    def __init__(self):
        self.settings = get_settings()
        self._lock = asyncio.Lock()
        self._base_url = f"https://{self.settings.amocrm_subdomain}.amocrm.ru"
    
    async def get_access_token(self) -> str:
        """Получает валидный access token (из кеша или обновляет)."""
        async with self._lock:
            # Пробуем получить из Redis
            cached = await self._get_cached_tokens()
            
            if cached and not cached.is_expired():
                logger.debug("Используем cached amoCRM токен")
                return cached.access_token
            
            # Токен истёк или отсутствует
            if cached and cached.refresh_token:
                logger.info("amoCRM токен истёк, обновляем через refresh_token")
                tokens = await self._refresh_tokens(cached.refresh_token)
            else:
                logger.warning("amoCRM токенов нет в кеше, требуется первичная авторизация")
                raise ValueError(
                    "Требуется первичная OAuth авторизация. "
                    f"Перейдите: {self._base_url}/oauth?client_id={self.settings.amocrm_client_id}&"
                    f"redirect_uri={self.settings.amocrm_redirect_uri}&response_type=code"
                )
            
            # Сохраняем в Redis
            await self._cache_tokens(tokens)
            
            return tokens.access_token
    
    async def exchange_code_for_tokens(self, code: str) -> AmoCRMTokens:
        """Обменивает authorization code на токены (первичная авторизация)."""
        logger.info("Обмен authorization code на токены")
        
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self._base_url}/oauth2/access_token",
                json={
                    "client_id": self.settings.amocrm_client_id,
                    "client_secret": self.settings.amocrm_client_secret.get_secret_value(),
                    "grant_type": "authorization_code",
                    "code": code,
                    "redirect_uri": self.settings.amocrm_redirect_uri,
                },
                timeout=30.0
            )
            response.raise_for_status()
            data = response.json()
        
        tokens = AmoCRMTokens(**data)
        await self._cache_tokens(tokens)
        
        logger.info("✅ amoCRM токены получены и сохранены")
        return tokens
    
    async def _refresh_tokens(self, refresh_token: str) -> AmoCRMTokens:
        """Обновляет токены через refresh_token."""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self._base_url}/oauth2/access_token",
                json={
                    "client_id": self.settings.amocrm_client_id,
                    "client_secret": self.settings.amocrm_client_secret.get_secret_value(),
                    "grant_type": "refresh_token",
                    "refresh_token": refresh_token,
                    "redirect_uri": self.settings.amocrm_redirect_uri,
                },
                timeout=30.0
            )
            response.raise_for_status()
            data = response.json()
        
        logger.info("✅ amoCRM токены обновлены")
        return AmoCRMTokens(**data)
    
    async def _get_cached_tokens(self) -> AmoCRMTokens | None:
        """Получает токены из Redis."""
        data = await redis_client.get(self.REDIS_KEY)
        if not data:
            return None
        
        import json
        tokens_dict = json.loads(data)
        return AmoCRMTokens(**tokens_dict)
    
    async def _cache_tokens(self, tokens: AmoCRMTokens) -> None:
        """Сохраняет токены в Redis."""
        import json
        await redis_client.setex(
            self.REDIS_KEY,
            self.TOKEN_TTL,
            json.dumps(tokens.model_dump(mode="json"))
        )
        logger.debug("amoCRM токены сохранены в Redis (TTL: %d сек)", self.TOKEN_TTL)


# Глобальный инстанс
auth_manager = AmoCRMAuthManager()
```

4. app/integrations/amocrm/client.py (НОВЫЙ)
```python
"""HTTP клиент для amoCRM API."""
import asyncio
from typing import Any

import httpx
from loguru import logger

from app.core.config import get_settings
from app.integrations.amocrm.auth import auth_manager
from app.integrations.amocrm.models import (
    AmoCRMContact,
    AmoCRMLead,
    AmoCRMNote,
)


class AmoCRMAPIError(Exception):
    """Базовая ошибка amoCRM API."""
    pass


class AmoCRMRateLimitError(AmoCRMAPIError):
    """Ошибка превышения лимита запросов."""
    pass


class AmoCRMClient:
    """Клиент для работы с amoCRM API."""
    
    MAX_RETRIES = 3
    RETRY_DELAY = 2.0  # секунды
    
    def __init__(self):
        self.settings = get_settings()
        self.base_url = f"https://{self.settings.amocrm_subdomain}.amocrm.ru/api/v4"
    
    async def create_lead(
        self,
        name: str,
        price: int | None = None,
        contact_id: int | None = None,
        pipeline_id: int | None = None,
        responsible_user_id: int | None = None,
        custom_fields: list[dict] | None = None,
    ) -> int:
        """Создаёт лид в amoCRM."""
        logger.info("Создание лида '%s' (цена: %s)", name, price)
        
        payload = {
            "name": name,
        }
        
        if price is not None:
            payload["price"] = price
        
        if pipeline_id is not None:
            payload["pipeline_id"] = pipeline_id
        
        if responsible_user_id is not None:
            payload["responsible_user_id"] = responsible_user_id
        
        if custom_fields:
            payload["custom_fields_values"] = custom_fields
        
        if contact_id:
            payload["_embedded"] = {
                "contacts": [{"id": contact_id}]
            }
        
        response = await self._request("POST", "/leads", json=[payload])
        
        lead_id = response["_embedded"]["leads"][0]["id"]
        logger.info("✅ Лид создан: ID=%d", lead_id)
        
        return lead_id
    
    async def create_contact(
        self,
        name: str,
        phone: str | None = None,
        email: str | None = None,
        custom_fields: list[dict] | None = None,
    ) -> int:
        """Создаёт контакт в amoCRM."""
        logger.info("Создание контакта '%s'", name)
        
        payload = {
            "name": name,
        }
        
        custom_fields_values = custom_fields or []
        
        if phone:
            custom_fields_values.append({
                "field_code": "PHONE",
                "values": [{"value": phone, "enum_code": "WORK"}]
            })
        
        if email:
            custom_fields_values.append({
                "field_code": "EMAIL",
                "values": [{"value": email, "enum_code": "WORK"}]
            })
        
        if custom_fields_values:
            payload["custom_fields_values"] = custom_fields_values
        
        response = await self._request("POST", "/contacts", json=[payload])
        
        contact_id = response["_embedded"]["contacts"][0]["id"]
        logger.info("✅ Контакт создан: ID=%d", contact_id)
        
        return contact_id
    
    async def add_note(
        self,
        entity_id: int,
        entity_type: str,
        text: str,
    ) -> int:
        """Добавляет примечание к сущности."""
        logger.debug("Добавление примечания к %s ID=%d", entity_type, entity_id)
        
        payload = {
            "entity_id": entity_id,
            "note_type": "common",
            "params": {"text": text}
        }
        
        response = await self._request(
            "POST",
            f"/{entity_type}/{entity_id}/notes",
            json=[payload]
        )
        
        note_id = response["_embedded"]["notes"][0]["id"]
        logger.debug("✅ Примечание добавлено: ID=%d", note_id)
        
        return note_id
    
    async def get_lead(self, lead_id: int) -> dict:
        """Получает лид по ID."""
        logger.debug("Получение лида ID=%d", lead_id)
        return await self._request("GET", f"/leads/{lead_id}")
    
    async def _request(
        self,
        method: str,
        endpoint: str,
        json: Any | None = None,
        params: dict | None = None,
        retry: int = 0,
    ) -> dict:
        """Выполняет HTTP запрос с обработкой ошибок и retry."""
        token = await auth_manager.get_access_token()
        
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }
        
        url = f"{self.base_url}{endpoint}"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.request(
                    method,
                    url,
                    headers=headers,
                    json=json,
                    params=params,
                    timeout=30.0
                )
            
            # 401 - токен истёк, пробуем обновить
            if response.status_code == 401 and retry < 1:
                logger.warning("amoCRM 401: токен истёк, пробуем обновить")
                # Инвалидируем кеш токенов
                from app.core.cache import redis_client
                await redis_client.delete("amocrm:tokens")
                return await self._request(method, endpoint, json, params, retry + 1)
            
            # 429 - rate limit
            if response.status_code == 429:
                if retry < self.MAX_RETRIES:
                    delay = self.RETRY_DELAY * (2 ** retry)  # exponential backoff
                    logger.warning(
                        "amoCRM rate limit, ждём %.1f сек (попытка %d/%d)",
                        delay, retry + 1, self.MAX_RETRIES
                    )
                    await asyncio.sleep(delay)
                    return await self._request(method, endpoint, json, params, retry + 1)
                else:
                    raise AmoCRMRateLimitError("Превышен лимит запросов к amoCRM")
            
            response.raise_for_status()
            return response.json()
        
        except httpx.HTTPStatusError as e:
            logger.error("amoCRM API ошибка %d: %s", e.response.status_code, e.response.text)
            raise AmoCRMAPIError(f"HTTP {e.response.status_code}: {e.response.text}")
        
        except httpx.RequestError as e:
            logger.error("amoCRM запрос провалился: %s", str(e))
            if retry < self.MAX_RETRIES:
                delay = self.RETRY_DELAY * (2 ** retry)
                logger.info("Повтор через %.1f сек", delay)
                await asyncio.sleep(delay)
                return await self._request(method, endpoint, json, params, retry + 1)
            raise AmoCRMAPIError(f"Request error: {str(e)}")


# Глобальный инстанс
amocrm_client = AmoCRMClient()
```

5. app/services/crm/__init__.py (НОВЫЙ)
```python
"""Сервисы CRM."""
from app.services.crm.amocrm_service import AmoCRMService

__all__ = ["AmoCRMService"]
```

6. app/services/crm/amocrm_service.py (НОВЫЙ)
```python
"""Бизнес-логика создания лидов из диалогов."""
from loguru import logger

from app.integrations.amocrm.client import amocrm_client
from app.integrations.amocrm.models import LeadCreateRequest, LeadCreateResponse


class AmoCRMService:
    """Сервис для работы с amoCRM лидами."""
    
    @staticmethod
    async def create_lead_from_conversation(
        request: LeadCreateRequest
    ) -> LeadCreateResponse:
        """
        Создаёт лид и контакт в amoCRM из данных диалога.
        
        Workflow:
        1. Создать контакт (если есть phone/email)
        2. Создать лид с привязкой к контакту
        3. Добавить примечание с историей диалога
        4. Добавить кастомные поля (источник, продукт)
        """
        logger.info(
            "Создание лида из диалога: %s (источник: %s)",
            request.user_name,
            request.source
        )
        
        contact_id = None
        
        # Шаг 1: Создать контакт (если есть данные)
        if request.phone or request.email:
            try:
                contact_id = await amocrm_client.create_contact(
                    name=request.user_name,
                    phone=request.phone,
                    email=request.email,
                )
            except Exception as e:
                logger.error("Ошибка создания контакта: %s", str(e))
                # Продолжаем без контакта
        
        # Шаг 2: Подготовить кастомные поля
        custom_fields = []
        
        # Источник лида (если есть кастомное поле)
        source_map = {
            "telegram": "Telegram Bot",
            "avito": "Avito Messenger",
            "web": "Веб-чат"
        }
        custom_fields.append({
            "field_code": "UTM_SOURCE",  # или ID вашего поля
            "values": [{"value": source_map.get(request.source, "Неизвестно")}]
        })
        
        # Продукт (если указан)
        if request.product_interest:
            custom_fields.append({
                "field_code": "PRODUCT",  # или ID вашего поля
                "values": [{"value": request.product_interest}]
            })
        
        # Шаг 3: Создать лид
        lead_name = f"Заявка от {request.user_name}"
        if request.product_interest:
            lead_name += f" ({request.product_interest})"
        
        try:
            lead_id = await amocrm_client.create_lead(
                name=lead_name,
                price=request.budget,
                contact_id=contact_id,
                custom_fields=custom_fields,
            )
        except Exception as e:
            logger.error("Ошибка создания лида: %s", str(e))
            return LeadCreateResponse(
                lead_id=0,
                contact_id=contact_id,
                success=False,
                message=f"Ошибка создания лида: {str(e)}"
            )
        
        # Шаг 4: Добавить примечание с историей диалога
        if request.conversation_history:
            try:
                await amocrm_client.add_note(
                    entity_id=lead_id,
                    entity_type="leads",
                    text=f"История диалога:\n\n{request.conversation_history}"
                )
            except Exception as e:
                logger.warning("Не удалось добавить примечание: %s", str(e))
                # Не критично
        
        logger.info("✅ Лид создан: lead_id=%d, contact_id=%s", lead_id, contact_id)
        
        return LeadCreateResponse(
            lead_id=lead_id,
            contact_id=contact_id,
            success=True,
            message="Лид успешно создан в amoCRM"
        )


# Глобальный инстанс
amocrm_service = AmoCRMService()
```

7. app/api/routes/amocrm.py (НОВЫЙ)
```python
"""API endpoints для amoCRM OAuth и управления."""
from fastapi import APIRouter, HTTPException, Query
from loguru import logger

from app.integrations.amocrm.auth import auth_manager
from app.integrations.amocrm.models import LeadCreateRequest
from app.services.crm.amocrm_service import amocrm_service


router = APIRouter(prefix="/amocrm", tags=["amoCRM"])


@router.get("/callback")
async def oauth_callback(
    code: str = Query(..., description="Authorization code"),
    state: str | None = Query(None)
):
    """
    OAuth callback endpoint для amoCRM.
    
    После авторизации amoCRM перенаправляет сюда с code.
    """
    logger.info("amoCRM OAuth callback: code=%s...", code[:20])
    
    try:
        tokens = await auth_manager.exchange_code_for_tokens(code)
        
        return {
            "success": True,
            "message": "Авторизация успешна! Токены сохранены.",
            "expires_in": tokens.expires_in
        }
    
    except Exception as e:
        logger.error("Ошибка OAuth авторизации: %s", str(e))
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/leads")
async def create_lead_endpoint(request: LeadCreateRequest):
    """Создаёт лид в amoCRM из данных диалога."""
    try:
        result = await amocrm_service.create_lead_from_conversation(request)
        
        if not result.success:
            raise HTTPException(status_code=400, detail=result.message)
        
        return result
    
    except Exception as e:
        logger.error("Ошибка создания лида: %s", str(e))
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/auth/url")
async def get_auth_url():
    """Возвращает URL для первичной OAuth авторизации."""
    from app.core.config import get_settings
    settings = get_settings()
    
    auth_url = (
        f"https://{settings.amocrm_subdomain}.amocrm.ru/oauth?"
        f"client_id={settings.amocrm_client_id}&"
        f"redirect_uri={settings.amocrm_redirect_uri}&"
        f"response_type=code&"
        f"state=random_state"
    )
    
    return {
        "auth_url": auth_url,
        "instructions": "Перейдите по ссылке для авторизации"
    }
```

8. app/core/settings.py (ОБНОВИТЬ)
   Добавить поля amoCRM:
```python
   from pydantic import SecretStr
   
   class Settings(BaseSettings):
       # ... существующие поля ...
       
       # amoCRM
       amocrm_subdomain: str = Field(default="", description="amoCRM subdomain")
       amocrm_client_id: str = Field(default="", description="amoCRM Client ID")
       amocrm_client_secret: SecretStr = Field(default="", description="amoCRM Client Secret")
       amocrm_redirect_uri: str = Field(
           default="https://smmassistant.online/api/v1/amocrm/callback",
           description="amoCRM OAuth redirect URI"
       )
```

9. app/api/__init__.py (ОБНОВИТЬ)
   Подключить роутер amoCRM:
```python
   from app.api.routes import amocrm
   
   def register_routes(app: FastAPI):
       # ... существующие роутеры ...
       app.include_router(amocrm.router, prefix="/api/v1")
```

10. tests/integration/test_amocrm.py (НОВЫЙ)
```python
"""Интеграционные тесты amoCRM клиента."""
import pytest
from unittest.mock import AsyncMock, patch

from app.integrations.amocrm.models import LeadCreateRequest
from app.services.crm.amocrm_service import amocrm_service


@pytest.mark.asyncio
async def test_create_lead_from_conversation():
    """Тест создания лида из диалога."""
    
    # Mock amoCRM API
    with patch("app.integrations.amocrm.client.amocrm_client.create_contact") as mock_contact, \
         patch("app.integrations.amocrm.client.amocrm_client.create_lead") as mock_lead, \
         patch("app.integrations.amocrm.client.amocrm_client.add_note") as mock_note:
        
        mock_contact.return_value = 12345
        mock_lead.return_value = 67890
        mock_note.return_value = 11111
        
        request = LeadCreateRequest(
            user_name="Иван Петров",
            phone="+79991234567",
            email="ivan@example.com",
            source="telegram",
            product_interest="AI Manager",
            budget=150000,
            conversation_history="История диалога..."
        )
        
        result = await amocrm_service.create_lead_from_conversation(request)
        
        assert result.success is True
        assert result.lead_id == 67890
        assert result.contact_id == 12345
        
        # Проверяем вызовы
        mock_contact.assert_called_once()
        mock_lead.assert_called_once()
        mock_note.assert_called_once()


@pytest.mark.asyncio
async def test_create_lead_without_contact():
    """Тест создания лида без контакта."""
    
    with patch("app.integrations.amocrm.client.amocrm_client.create_lead") as mock_lead:
        mock_lead.return_value = 67890
        
        request = LeadCreateRequest(
            user_name="Аноним",
            source="web",
            product_interest="AI Analyst"
        )
        
        result = await amocrm_service.create_lead_from_conversation(request)
        
        assert result.success is True
        assert result.lead_id == 67890
        assert result.contact_id is None
```

WORKFLOW ПЕРВИЧНОЙ АВТОРИЗАЦИИ:

1. Получить auth URL:
   GET /api/v1/amocrm/auth/url

2. Перейти по ссылке в браузере → авторизоваться в amoCRM

3. amoCRM перенаправит на callback:
   https://smmassistant.online/api/v1/amocrm/callback?code=def502...

4. Endpoint обменяет code на токены и сохранит в Redis

5. После этого все API методы работают автоматически

ИСПОЛЬЗОВАНИЕ В ДРУГИХ СЕРВИСАХ:
```python
# В Telegram handler
from app.integrations.amocrm.models import LeadCreateRequest
from app.services.crm.amocrm_service import amocrm_service

async def create_lead_from_telegram(chat_id: int, user_name: str):
    request = LeadCreateRequest(
        user_name=user_name,
        source="telegram",
        product_interest="AI Manager",
        conversation_history="История из Redis..."
    )
    
    result = await amocrm_service.create_lead_from_conversation(request)
    if result.success:
        logger.info("Лид создан: ID=%d", result.lead_id)
```

ЛОГИРОВАНИЕ:
- INFO: создание лидов, OAuth события
- DEBUG: получение токенов, API запросы
- WARNING: retry попытки, истечение токенов
- ERROR: ошибки API, валидации

⚠️ КРИТИЧНО:
- НЕ ИЗМЕНЯЙ .env ФАЙЛ!
- Все токены только в Redis (TTL 86400 сек)
- Exponential backoff для rate limit
- Обработка 401 (токен истёк)
- Типизация везде (Pydantic)
- Async везде

КАСТОМНЫЕ ПОЛЯ:
- Если в amoCRM есть кастомные поля "Источник" и "Продукт"
- Найди их ID через API: GET /api/v4/leads/custom_fields
- Замени "UTM_SOURCE" и "PRODUCT" на реальные field_id

ТЕСТИРОВАНИЕ:
1. Запустить сервер
2. Получить auth URL: GET /api/v1/amocrm/auth/url
3. Авторизоваться
4. Протестировать создание лида: POST /api/v1/amocrm/leads

✅ КРИТЕРИИ ГОТОВНОСТИ T029:
- [ ] Все файлы созданы
- [ ] OAuth авторизация работает
- [ ] Токены кешируются в Redis
- [ ] create_lead() создаёт лид
- [ ] create_contact() создаёт контакт
- [ ] add_note() добавляет примечание
- [ ] Rate limit обрабатывается
- [ ] 401 обрабатывается (обновление токена)
- [ ] Тесты проходят
- [ ] Логирование работает